<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:;base64,iVBORw0KGgo="> <title>Street Surf - Aurora Theme</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .hud, #gameOverScreen, #pauseScreen {
            font-family: 'Inter', sans-serif;
        }
        .hud {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 20px; box-sizing: border-box; display: flex;
            justify-content: space-between; 
            align-items: flex-start; 
            color: white; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 1;
            pointer-events: none; 
        }
        
        #hud-left {
            display: flex;
            flex-direction: column; 
            text-align: left;
        }

        #highScore {
            text-align: center;
        }
        
        #hud-right {
             width: 50px; 
             margin-right: 20px; 
        }

        #pauseButton {
            position: absolute;
            top: 20px;
            right: 20px; 
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 24px;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3; 
            pointer-events: auto; /* Pause button ko clickable banaya */
        }

        #gameOverScreen, #pauseScreen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(15, 23, 42, 0.8);
            color: white; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; z-index: 2;
        }
        #gameOverScreen h1, #pauseScreen h1 { font-size: 48px; margin: 0; } 
        #gameOverScreen p { font-size: 24px; }
        
        #restartButton, #resumeButton { 
            padding: 15px 30px; font-size: 20px; font-weight: bold;
            color: white;
            background: linear-gradient(90deg, #38bdf8, #8b5cf6);
            border: none; border-radius: 10px; cursor: pointer; margin-top: 20px;
        }
    </style>
</head>
<body>

    <audio id="musicSound" src="sounds/music.mp3" loop></audio>
    <audio id="jumpSound" src="sounds/jump.wav"></audio>
    <audio id="coinSound" src="sounds/coin.wav"></audio>
    <audio id="crashSound" src="sounds/crash.wav"></audio>

    <div class="hud">
        <div id="hud-left">
            <div id="score">Score: 0</div>
            <div id="coins">Coins: 0</div>
        </div>
        <div id="highScore">High Score: 0</div>
        <div id="hud-right"></div>
    </div>

    <button id="pauseButton">||</button> 

    <div id="pauseScreen"> 
        <h1>Paused</h1>
        <button id="resumeButton">Resume</button>
    </div>
    
    <div id="gameOverScreen">
        <h1>Game Over</h1>
        <p id="finalScore"></p>
        <button id="restartButton">Restart</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- Scene, Camera, and Renderer ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); 
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- Game Setup Variables ---
        const groundSegments = [], obstacles = [], coins = [], powerups = [];
        const segmentLength = 200, numSegments = 3, laneWidth = 5;
        let player, playerHitbox, originalPlayerMaterial;
        let playerSpeed = 0.5;
        let currentLane = 0;
        let isJumping = false, isSliding = false, jumpVelocity = 0, slideTimer = 0;
        const gravity = -0.025, jumpPower = 0.4;
        let gameOver = false, score = 0, coinCount = 0, highScore = 0;
        
        let magnetActive = false, magnetTimer = 0;
        let invincibleActive = false, invincibilityTimer = 0;
        const invincibilityMaterial = new THREE.MeshStandardMaterial({ color: 0x38bdf8, emissive: 0x8b5cf6 });

        let doubleCoinsActive = false, doubleCoinsTimer = 0;
        const doubleCoinsMaterial = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x16a34a });
        const playerDoubleCoinsMaterial = new THREE.MeshStandardMaterial({ color: 0xa3e635, emissive: 0x84cc16 }); 

        let isPaused = false;

        // --- NAYA CODE: MOBILE ---
        let touchStartX = 0, touchStartY = 0; // Touch start position
        // --- END NAYA CODE ---

        // --- Speed Variables ---
        let maxPlayerSpeed = 1.0; 
        let speedIncreaseFactor = 0.0001; 

        // --- UI and Controls ---
        const scoreElement = document.getElementById('score');
        const coinsElement = document.getElementById('coins');
        const highScoreElement = document.getElementById('highScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        const pauseButton = document.getElementById('pauseButton');
        const pauseScreen = document.getElementById('pauseScreen');
        const resumeButton = document.getElementById('resumeButton');

        // --- Sounds ---
        const musicSound = document.getElementById('musicSound');
        const jumpSound = document.getElementById('jumpSound');
        const coinSound = document.getElementById('coinSound');
        const crashSound = document.getElementById('crashSound');

        // --- Keyboard Controls ---
        const keys = {};
        window.addEventListener('keydown', (event) => { 
            keys[event.key.toLowerCase()] = true; 
            if (event.key.toLowerCase() === 'p') {
                togglePause();
            }
        });
        window.addEventListener('keyup', (event) => { keys[event.key.toLowerCase()] = false; });
        
        // --- Button Controls ---
        restartButton.addEventListener('click', () => { window.location.reload(); });
        pauseButton.addEventListener('click', togglePause);
        resumeButton.addEventListener('click', togglePause);

        // --- NAYA CODE: MOBILE TOUCH CONTROLS ---
        window.addEventListener('touchstart', handleTouchStart, { passive: false });
        window.addEventListener('touchend', handleTouchEnd, { passive: false });

        function handleTouchStart(event) {
            // Pause button par touch ho toh ignore karo
            if (event.target === pauseButton) return;
            
            if (isPaused || gameOver) return;
            event.preventDefault(); // Screen ko scroll hone se roko
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchEnd(event) {
            if (event.target === pauseButton) return;
            
            if (isPaused || gameOver || touchStartX === 0) return;
            event.preventDefault(); 

            let touchEndX = event.changedTouches[0].clientX;
            let touchEndY = event.changedTouches[0].clientY;

            let diffX = touchEndX - touchStartX;
            let diffY = touchEndY - touchStartY;
            
            let swipeThreshold = 50; // Minimum 50px swipe chahiye

            // Check karo ki swipe horizontal hai ya vertical
            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal swipe
                if (diffX > swipeThreshold && currentLane < 1) { // Swipe Right
                    currentLane++;
                } else if (diffX < -swipeThreshold && currentLane > -1) { // Swipe Left
                    currentLane--;
                }
            } else {
                // Vertical swipe
                if (diffY > swipeThreshold && !isJumping && !isSliding) { // Swipe Down
                    isSliding = true; 
                    slideTimer = 40;
                } else if (diffY < -swipeThreshold && !isJumping && !isSliding) { // Swipe Up
                    isJumping = true; 
                    jumpVelocity = jumpPower; 
                    jumpSound.play();
                }
            }

            // Reset start coordinates
            touchStartX = 0;
            touchStartY = 0;
        }
        // --- END NAYA CODE ---

        function togglePause() {
            if (gameOver) return; 
            isPaused = !isPaused; 
            if (isPaused) {
                pauseScreen.style.display = 'flex'; 
                musicSound.pause(); 
            } else {
                pauseScreen.style.display = 'none'; 
                musicSound.play(); 
                animate(); 
            }
        }

        function loadHighScore() {
            const savedHighScore = localStorage.getItem('streetSurfHighScore');
            if (savedHighScore) {
                highScore = parseInt(savedHighScore, 10);
                highScoreElement.innerText = `High Score: ${highScore}`;
            }
        }

        // --- Ground ---
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x334155 });
        for (let i = 0; i < numSegments; i++) {
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(15, segmentLength), groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.position.z = -i * segmentLength;
            scene.add(ground);
            groundSegments.push(ground);
        }
        
        // --- Spawning Logic ---
        let nextSpawnZ = -40;
        function spawnEntities() {
            const randomLane = Math.floor(Math.random() * 3) - 1;
            const spawnType = Math.random();
            if (spawnType < 0.15 && nextSpawnZ < -100) { // Train
                const trainLength = Math.floor(Math.random() * 5) + 3;
                for (let i = 0; i < trainLength; i++) {
                    const carriage = new THREE.Mesh(new THREE.BoxGeometry(4, 5, 15), new THREE.MeshStandardMaterial({ color: 0x475569 }));
                    carriage.position.set(randomLane * laneWidth, 2, nextSpawnZ - i * 16);
                    carriage.userData = { type: 'train' };
                    scene.add(carriage); obstacles.push(carriage);
                }
            } else if (spawnType < 0.65) { // Obstacle
                const isTall = Math.random() > 0.5;
                const obstacle = new THREE.Mesh(isTall ? new THREE.BoxGeometry(4, 4, 4) : new THREE.BoxGeometry(14, 2, 4), new THREE.MeshStandardMaterial({ color: 0x7c3aed }));
                obstacle.position.set(isTall ? randomLane * laneWidth : 0, isTall ? 1.5 : 0.5, nextSpawnZ);
                obstacle.userData = { type: 'obstacle' };
                scene.add(obstacle); obstacles.push(obstacle);
            } else if (spawnType < 0.9) { // Coins
                for (let i = 0; i < 5; i++) {
                    const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xccac00 }));
                    coin.position.set(randomLane * laneWidth, 0.5, nextSpawnZ - i * 3);
                    coin.rotation.x = Math.PI / 2;
                    scene.add(coin); coins.push(coin);
                }
            } else { 
                // 3-way Power-up
                const powerupType = Math.random();
                let powerup;
                if (powerupType < 0.33) { // Magnet
                    powerup = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.2, 16, 100), new THREE.MeshStandardMaterial({ color: 0x9013fe, emissive: 0x9013fe }));
                    powerup.userData.type = 'magnet';
                } else if (powerupType < 0.66) { // Invincibility
                    powerup = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshStandardMaterial({ color: 0x38bdf8, emissive: 0x38bdf8 }));
                    powerup.userData.type = 'invincibility';
                } else { // 2x Coins
                    powerup = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), doubleCoinsMaterial);
                    powerup.userData.type = 'doubleCoins';
                }

                powerup.position.set(randomLane * laneWidth, 1, nextSpawnZ);
                scene.add(powerup); powerups.push(powerup);
            }
            nextSpawnZ -= Math.random() * 40 + 40;
        }
        for(let i=0; i<50; i++) { spawnEntities(); }

        // --- Player ---
        const loader = new THREE.GLTFLoader();
        loader.load('models/player/scene.gltf', (gltf) => {
            player = gltf.scene;
            player.scale.set(0.6, 0.6, 0.6);
            player.position.set(0, 0, 0);
            scene.add(player);
            const hitboxGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            playerHitbox = new THREE.Mesh(hitboxGeometry, new THREE.MeshBasicMaterial({ visible: false }));
            scene.add(playerHitbox);
            player.traverse(child => { 
                if (child.isMesh) {
                    originalPlayerMaterial = child.material; 
                }
            });
            loadHighScore();
            musicSound.play().catch(e => console.log("Music play failed. User interaction needed."));
            animate();
        }, undefined, (error) => {
            console.error('An error happened while loading the player model:', error);
            alert('Could not load player model. Make sure the files are in the correct "models/player" folder and you are using a Live Server.');
        });

        // --- Animation Loop ---
        function animate() {
            if (gameOver || isPaused) {
                if (isPaused) {
                    renderer.render(scene, camera); 
                }
                return;
            }
            requestAnimationFrame(animate);

            if (!player) return;

            score += 0.2;
            scoreElement.innerText = `Score: ${Math.floor(score)}`;
            
            if (playerSpeed < maxPlayerSpeed) {
                playerSpeed += speedIncreaseFactor;
            }

            // --- Keyboard Controls Logic ---
            // (Yeh touch controls ke saath milkar kaam karega)
            if (keys['arrowleft'] && currentLane > -1) { 
                currentLane--; 
                keys['arrowleft'] = false; // Key ko consume karo
            }
            if (keys['arrowright'] && currentLane < 1) { 
                currentLane++; 
                keys['arrowright'] = false; // Key ko consume karo
            }
            if (keys['arrowup'] && !isJumping && !isSliding) { 
                isJumping = true; 
                jumpVelocity = jumpPower; 
                jumpSound.play();
                // Yahan key consume nahi karte kyunki 'isJumping' lock ka kaam karta hai
            }
            if (keys['arrowdown'] && !isJumping && !isSliding) { 
                isSliding = true; 
                slideTimer = 40; 
                // Yahan bhi 'isSliding' lock ka kaam karta hai
            }
            // --- End Keyboard Controls Logic ---


            // Treadmill logic
            groundSegments.forEach(s => { s.position.z += playerSpeed; if (s.position.z > segmentLength) s.position.z -= numSegments * segmentLength; });
            [...obstacles, ...coins, ...powerups].forEach(obj => {
                const speedMultiplier = (obj.userData.type === 'train') ? 1.5 : 1;
                obj.position.z += playerSpeed * speedMultiplier;
                if (obj.position.z > camera.position.z + 20) { obj.position.z -= 800; obj.visible = true; }
            });

            // Player movement
            player.position.x = THREE.MathUtils.lerp(player.position.x, currentLane * laneWidth, 0.2);
            
            if (isJumping) { 
                player.position.y += jumpVelocity; 
                jumpVelocity += gravity; 
                if (player.position.y <= 0) { 
                    player.position.y = 0; 
                    isJumping = false; 
                } 
            }
            if (isSliding) { 
                player.scale.y = 0.3; 
                slideTimer--; 
                if (slideTimer <= 0) { 
                    isSliding = false; 
                    player.scale.y = 0.6; 
                } 
            }

            // Power-up logic...
            if (magnetActive && --magnetTimer <= 0) magnetActive = false;
            
            if (invincibleActive && --invincibilityTimer <= 0) {
                invincibleActive = false;
                if (!doubleCoinsActive) {
                    player.traverse(child => { if (child.isMesh) child.material = originalPlayerMaterial; });
                } else {
                    player.traverse(child => { if (child.isMesh) child.material = playerDoubleCoinsMaterial; });
                }
            }

            if (doubleCoinsActive && --doubleCoinsTimer <= 0) {
                doubleCoinsActive = false;
                if (!invincibleActive) {
                    player.traverse(child => { if (child.isMesh) child.material = originalPlayerMaterial; });
                } else {
                    player.traverse(child => { if (child.isMesh) child.material = invincibilityMaterial; });
                }
            }

            if (magnetActive) { coins.forEach(c => { if(c.visible && player.position.distanceTo(c.position) < 10) c.position.lerp(player.position, 0.1); }); }
            
            // Collision logic...
            playerHitbox.position.copy(player.position);
            playerHitbox.position.y += 0.9;
            const playerCollider = new THREE.Box3().setFromObject(playerHitbox);
            
            if (!invincibleActive) {
                for (const obstacle of obstacles) {
                    if (player.position.distanceTo(obstacle.position) < 15) {
                        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                        if (playerCollider.intersectsBox(obstacleBox)) {
                            musicSound.pause();
                            crashSound.play();
                            gameOver = true;
                            if (score > highScore) {
                                highScore = Math.floor(score);
                                localStorage.setItem('streetSurfHighScore', highScore);
                            }
                            finalScoreElement.innerText = `Your Score: ${Math.floor(score)} | High Score: ${highScore}`;
                            gameOverScreen.style.display = 'flex';
                            return;
                        }
                    }
                }
            }
            
            [...coins, ...powerups].forEach(item => {
                if (item.visible) {
                    const itemBox = new THREE.Box3().setFromObject(item);
                        if (playerCollider.intersectsBox(itemBox)) {
                            item.visible = false;
                            
                            if (coins.includes(item)) {
                                const coinsToAdd = doubleCoinsActive ? 2 : 1;
                                coinCount += coinsToAdd;
                                coinsElement.innerText = `Coins: ${coinCount}`;
                                coinSound.currentTime = 0;
                                coinSound.play();
                            } else { // It's a power-up
                                if (item.userData.type === 'magnet') { 
                                    magnetActive = true; 
                                    magnetTimer = 300; 
                                }
                                if (item.userData.type === 'invincibility') {
                                    invincibleActive = true; 
                                    invincibilityTimer = 300;
                                    player.traverse(child => { if (child.isMesh) child.material = invincibilityMaterial; });
                                }
                                if (item.userData.type === 'doubleCoins') {
                                    doubleCoinsActive = true;
                                    doubleCoinsTimer = 300;
                                    if (!invincibleActive) {
                                        player.traverse(child => { if (child.isMesh) child.material = playerDoubleCoinsMaterial; });
                                    }
                                }
                            }
                        }
                }
            });

            // Camera logic...
            camera.position.set(player.position.x, player.position.y + 4, player.position.z + 10);
            camera.lookAt(player.position);
            
            renderer.render(scene, camera);
        }
    </script>

</body>
</html>
